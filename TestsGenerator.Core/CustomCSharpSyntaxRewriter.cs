using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace TestsGenerator.Core
{
    internal class CustomCSharpSyntaxRewriter : CSharpSyntaxRewriter
    {
        public Dictionary<string, List<ClassDeclarationSyntax>> ClassesByNamespace { get; set; } = new();
        private string _currentNamespace;

        public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
        {
            //var identifier = SyntaxFactory.Identifier(node.Identifier.ValueText + "Tests")
            //    .WithTrailingTrivia(SyntaxFactory.ElasticCarriageReturnLineFeed);

            //var baseList = SyntaxFactory.BaseList();

            //var newNode = SyntaxFactory.ClassDeclaration(new SyntaxList<AttributeListSyntax>(),
            //    node.Modifiers,
            //    node.Keyword,
            //    identifier,
            //    node.TypeParameterList,
            //    null,
            //    node.ConstraintClauses,
            //    node.OpenBraceToken,
            //    node.Members,
            //    node.CloseBraceToken,
            //    node.SemicolonToken);

            if (node.Parent is NamespaceDeclarationSyntax ns)
            {
                _currentNamespace = ns.Name.ToString();
            }

            if (!ClassesByNamespace.ContainsKey(_currentNamespace))
            {
                ClassesByNamespace.Keys.Append(_currentNamespace);
                ClassesByNamespace[_currentNamespace] = new List<ClassDeclarationSyntax>();
            };
            ClassesByNamespace[_currentNamespace].Add(node);
            base.VisitClassDeclaration(node);
            return node;
        }

        //public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
        //{
        //    var attribute = SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("Fact"));
        //    var attributeList = SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList<AttributeSyntax>(attribute));
        //    var attributeLists = new SyntaxList<AttributeListSyntax>(attributeList);

        //    var identifier = SyntaxFactory.Identifier(node.Identifier.ValueText + "Test");

        //    var newNode = SyntaxFactory.MethodDeclaration(
        //        attributeLists,
        //        node.Modifiers,
        //        SyntaxFactory.IdentifierName("void"),
        //        node.ExplicitInterfaceSpecifier,
        //        identifier,
        //        node.TypeParameterList,
        //        SyntaxFactory.ParameterList(),
        //        node.ConstraintClauses,
        //        SyntaxFactory.Block(SyntaxFactory.ParseStatement(@"Assert.Fail(""autogenerated"");")),
        //        node.SemicolonToken
        //        );
        //    return newNode;
        //}

        public string GetNamespaceFrom(SyntaxNode s) =>
            s.Parent switch
            {
                NamespaceDeclarationSyntax namespaceDeclarationSyntax => namespaceDeclarationSyntax.Name.ToString(),
                null => string.Empty, // or whatever you want to do
                _ => GetNamespaceFrom(s.Parent)
            };
    }
}
