using System.Text;
using System.Threading.Tasks.Dataflow;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using TestsGenerator.Core.Models;

namespace TestsGenerator.Core
{
    public class Generator
    {
        public async Task GenerateAsync(string[] files, string storePath, int loadInMemoryRestriction, int generationRestriction, int loadFromMemoryRestriction)
        {

            var readFromFileBlock = new TransformBlock<string, FileModel>(async path =>
            {
                System.Console.WriteLine($"Opening file {path}");
                FileModel result = new();
                using (StreamReader fileStream = File.OpenText(path))
                {
                    result.Name = Path.GetFileName(path);
                    result.Content = await fileStream.ReadToEndAsync();
                }
                return result;
            });

            var generateTestFileBlock = new TransformBlock<FileModel, FileModel>(input =>
            {
                SyntaxTree tree = CSharpSyntaxTree.ParseText(input.Content);
                System.Console.WriteLine($"Generating tests class for file {tree.FilePath}");
                var root = tree.GetCompilationUnitRoot();

                var xunit = SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName("Xunit"));

                var usings = root.Usings.ToList();


                usings.Add(xunit);

                var visitor = new CustomCSharpSyntaxRewriter();
                visitor.Visit(root);
                var namespaces = new List<MemberDeclarationSyntax>();

                foreach(var namespaceName in visitor.ClassesByNamespace.Keys)
                {
                    var usingDirective = SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(namespaceName));
                    usings.Add(usingDirective);
                    var classDeclarations = new List<MemberDeclarationSyntax>();

                    
                    foreach (var classDeclaration in visitor.ClassesByNamespace[namespaceName])
                    {
                        var attributes = SyntaxFactory.AttributeList();
                        var modifier = SyntaxFactory.Token(SyntaxKind.PublicKeyword);
                        var identifier = SyntaxFactory.Identifier(classDeclaration.Identifier.ValueText + "Tests");

                        var methods = classDeclaration.Members
                            .OfType<MethodDeclarationSyntax>()
                            .Select(x =>
                            {
                                return SyntaxFactory.MethodDeclaration(
                                    new SyntaxList<AttributeListSyntax>(),
                                    new SyntaxTokenList(modifier),
                                    SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),
                                    null,
                                    SyntaxFactory.Identifier(x.Identifier.ValueText + "Test"),
                                    null,
                                    SyntaxFactory.ParameterList(),
                                    new SyntaxList<TypeParameterConstraintClauseSyntax>(),
                                    SyntaxFactory.Block(SyntaxFactory.ParseStatement(@"Assert.Fail(""autogenerated"");")),
                                    null);
                            });

                        var declarationToAdd = SyntaxFactory.ClassDeclaration(
                            new SyntaxList<AttributeListSyntax>(),                  //Attribute list
                            new SyntaxTokenList() { modifier },                     //Modifiers
                            identifier,                                             //Identifier
                            null,                                                   //Type parameter list
                            null,                                                   //Base list
                            new SyntaxList<TypeParameterConstraintClauseSyntax>(),  //Constraint clauses list
                            SyntaxFactory.List<MemberDeclarationSyntax>(methods));

                        classDeclarations.Add(declarationToAdd);
                    }

                    var namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(
                        SyntaxFactory.IdentifierName(namespaceName + ".Tests"),
                        new SyntaxList<ExternAliasDirectiveSyntax>(),
                        new SyntaxList<UsingDirectiveSyntax>(),
                        SyntaxFactory.List(classDeclarations)
                        );

                    namespaces.Add(namespaceDeclaration);
                 }

                var resultCompilationUnit = SyntaxFactory.CompilationUnit(
                    new SyntaxList<ExternAliasDirectiveSyntax>(),
                    SyntaxFactory.List(usings),
                    new SyntaxList<AttributeListSyntax>(),
                    SyntaxFactory.List(namespaces));


                resultCompilationUnit = (CompilationUnitSyntax)Formatter.Format(resultCompilationUnit, new AdhocWorkspace());
                FileModel result = new()
                {
                    Name = input.Name,
                    Content = resultCompilationUnit.ToString()
                };

                return result;
            });

            var writeToFileBlock = new ActionBlock<FileModel>(async input =>
            {
                System.Console.WriteLine($"Writing file");
                using (FileStream fileStream = File.Create(storePath + $"\\{input.Name}"))
                {
                    byte[] info = new UTF8Encoding(true).GetBytes(input.Content);
                    await fileStream.WriteAsync(info);
                }
            });

            var linkOptions = new DataflowLinkOptions { PropagateCompletion = true };

            readFromFileBlock.LinkTo(generateTestFileBlock, linkOptions);
            generateTestFileBlock.LinkTo(writeToFileBlock, linkOptions);

            foreach (var file in files)
            {
                await readFromFileBlock.SendAsync(file);
            }

            readFromFileBlock.Complete();

            writeToFileBlock.Completion.Wait();
        }
    }
}
